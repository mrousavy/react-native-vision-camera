///
/// HybridCameraDeviceControllerSpecSwift.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include "HybridCameraDeviceControllerSpec.hpp"

// Forward declaration of `HybridCameraDeviceControllerSpec_cxx` to properly resolve imports.
namespace VisionCamera { class HybridCameraDeviceControllerSpec_cxx; }

// Forward declaration of `HybridCameraDeviceSpec` to properly resolve imports.
namespace margelo::nitro::camera { class HybridCameraDeviceSpec; }
// Forward declaration of `HybridCameraFormatSpec` to properly resolve imports.
namespace margelo::nitro::camera { class HybridCameraFormatSpec; }
// Forward declaration of `Range` to properly resolve imports.
namespace margelo::nitro::camera { struct Range; }
// Forward declaration of `FocusMode` to properly resolve imports.
namespace margelo::nitro::camera { enum class FocusMode; }
// Forward declaration of `ExposureMode` to properly resolve imports.
namespace margelo::nitro::camera { enum class ExposureMode; }
// Forward declaration of `WhiteBalanceMode` to properly resolve imports.
namespace margelo::nitro::camera { enum class WhiteBalanceMode; }
// Forward declaration of `ColorSpace` to properly resolve imports.
namespace margelo::nitro::camera { enum class ColorSpace; }
// Forward declaration of `SetCameraDeviceConfiguration` to properly resolve imports.
namespace margelo::nitro::camera { struct SetCameraDeviceConfiguration; }
// Forward declaration of `Point` to properly resolve imports.
namespace margelo::nitro::camera { struct Point; }
// Forward declaration of `Rect` to properly resolve imports.
namespace margelo::nitro::camera { struct Rect; }
// Forward declaration of `WhiteBalanceGains` to properly resolve imports.
namespace margelo::nitro::camera { struct WhiteBalanceGains; }

#include <memory>
#include "HybridCameraDeviceSpec.hpp"
#include "HybridCameraFormatSpec.hpp"
#include <optional>
#include "Range.hpp"
#include "FocusMode.hpp"
#include "ExposureMode.hpp"
#include "WhiteBalanceMode.hpp"
#include "ColorSpace.hpp"
#include <NitroModules/Promise.hpp>
#include "SetCameraDeviceConfiguration.hpp"
#include "Point.hpp"
#include "Rect.hpp"
#include "WhiteBalanceGains.hpp"

#include "VisionCamera-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::camera {

  /**
   * The C++ part of HybridCameraDeviceControllerSpec_cxx.swift.
   *
   * HybridCameraDeviceControllerSpecSwift (C++) accesses HybridCameraDeviceControllerSpec_cxx (Swift), and might
   * contain some additional bridging code for C++ <> Swift interop.
   *
   * Since this obviously introduces an overhead, I hope at some point in
   * the future, HybridCameraDeviceControllerSpec_cxx can directly inherit from the C++ class HybridCameraDeviceControllerSpec
   * to simplify the whole structure and memory management.
   */
  class HybridCameraDeviceControllerSpecSwift: public virtual HybridCameraDeviceControllerSpec {
  public:
    // Constructor from a Swift instance
    explicit HybridCameraDeviceControllerSpecSwift(const VisionCamera::HybridCameraDeviceControllerSpec_cxx& swiftPart):
      HybridObject(HybridCameraDeviceControllerSpec::TAG),
      _swiftPart(swiftPart) { }

  public:
    // Get the Swift part
    inline VisionCamera::HybridCameraDeviceControllerSpec_cxx& getSwiftPart() noexcept {
      return _swiftPart;
    }

  public:
    inline size_t getExternalMemorySize() noexcept override {
      return _swiftPart.getMemorySize();
    }
    void dispose() noexcept override {
      _swiftPart.dispose();
    }
    std::string toString() override {
      return _swiftPart.toString();
    }

  public:
    // Properties
    inline std::shared_ptr<HybridCameraDeviceSpec> getDevice() noexcept override {
      auto __result = _swiftPart.getDevice();
      return __result;
    }
    inline std::shared_ptr<HybridCameraFormatSpec> getActiveFormat() noexcept override {
      auto __result = _swiftPart.getActiveFormat();
      return __result;
    }
    inline std::optional<std::shared_ptr<HybridCameraFormatSpec>> getActiveDepthFormat() noexcept override {
      auto __result = _swiftPart.getActiveDepthFormat();
      return __result;
    }
    inline bool getEnableAutoFrameRate() noexcept override {
      return _swiftPart.getEnableAutoFrameRate();
    }
    inline Range getFps() noexcept override {
      return _swiftPart.getFps();
    }
    inline FocusMode getFocusMode() noexcept override {
      auto __result = _swiftPart.getFocusMode();
      return static_cast<FocusMode>(__result);
    }
    inline bool getEnableSmoothAutoFocus() noexcept override {
      return _swiftPart.getEnableSmoothAutoFocus();
    }
    inline bool getEnableFaceDrivenAutoFocus() noexcept override {
      return _swiftPart.getEnableFaceDrivenAutoFocus();
    }
    inline ExposureMode getExposureMode() noexcept override {
      auto __result = _swiftPart.getExposureMode();
      return static_cast<ExposureMode>(__result);
    }
    inline bool getEnableFaceDrivenAutoExposure() noexcept override {
      return _swiftPart.getEnableFaceDrivenAutoExposure();
    }
    inline WhiteBalanceMode getWhiteBalanceMode() noexcept override {
      auto __result = _swiftPart.getWhiteBalanceMode();
      return static_cast<WhiteBalanceMode>(__result);
    }
    inline bool getAutomaticallyEnableLowLightBoost() noexcept override {
      return _swiftPart.getAutomaticallyEnableLowLightBoost();
    }
    inline bool getEnableVideoHDR() noexcept override {
      return _swiftPart.getEnableVideoHDR();
    }
    inline bool getAutomaticallyEnableVideoHDR() noexcept override {
      return _swiftPart.getAutomaticallyEnableVideoHDR();
    }
    inline bool getEnableGlobalToneMapping() noexcept override {
      return _swiftPart.getEnableGlobalToneMapping();
    }
    inline ColorSpace getColorSpace() noexcept override {
      auto __result = _swiftPart.getColorSpace();
      return static_cast<ColorSpace>(__result);
    }
    inline double getZoom() noexcept override {
      return _swiftPart.getZoom();
    }

  public:
    // Methods
    inline std::shared_ptr<Promise<void>> configure(const SetCameraDeviceConfiguration& config) override {
      auto __result = _swiftPart.configure(std::forward<decltype(config)>(config));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> setFocusPoint(const Point& point) override {
      auto __result = _swiftPart.setFocusPoint(std::forward<decltype(point)>(point));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> setFocusRect(const Rect& rect) override {
      auto __result = _swiftPart.setFocusRect(std::forward<decltype(rect)>(rect));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> setFocusLensPosition(double lensPosition) override {
      auto __result = _swiftPart.setFocusLensPosition(std::forward<decltype(lensPosition)>(lensPosition));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> setExposurePoint(const Point& point) override {
      auto __result = _swiftPart.setExposurePoint(std::forward<decltype(point)>(point));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> setExposureBias(double exposure) override {
      auto __result = _swiftPart.setExposureBias(std::forward<decltype(exposure)>(exposure));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> setExposureRect(const Rect& rect) override {
      auto __result = _swiftPart.setExposureRect(std::forward<decltype(rect)>(rect));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> setExposureLocked(double duration, double iso) override {
      auto __result = _swiftPart.setExposureLocked(std::forward<decltype(duration)>(duration), std::forward<decltype(iso)>(iso));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> setWhiteBalanceLocked(const WhiteBalanceGains& whiteBalanceGains) override {
      auto __result = _swiftPart.setWhiteBalanceLocked(std::forward<decltype(whiteBalanceGains)>(whiteBalanceGains));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> enableTorch(double level) override {
      auto __result = _swiftPart.enableTorch(std::forward<decltype(level)>(level));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> startZoomAnimation(double zoom, double rate) override {
      auto __result = _swiftPart.startZoomAnimation(std::forward<decltype(zoom)>(zoom), std::forward<decltype(rate)>(rate));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }
    inline std::shared_ptr<Promise<void>> cancelZoomAnimation() override {
      auto __result = _swiftPart.cancelZoomAnimation();
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
      auto __value = std::move(__result.value());
      return __value;
    }

  private:
    VisionCamera::HybridCameraDeviceControllerSpec_cxx _swiftPart;
  };

} // namespace margelo::nitro::camera
