///
/// SetCameraDeviceConfiguration.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/JSIConverter.hpp>)
#include <NitroModules/JSIConverter.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/NitroDefines.hpp>)
#include <NitroModules/NitroDefines.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/JSIHelpers.hpp>)
#include <NitroModules/JSIHelpers.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `HybridCameraFormatSpec` to properly resolve imports.
namespace margelo::nitro::camera { class HybridCameraFormatSpec; }
// Forward declaration of `Range` to properly resolve imports.
namespace margelo::nitro::camera { struct Range; }
// Forward declaration of `FocusMode` to properly resolve imports.
namespace margelo::nitro::camera { enum class FocusMode; }
// Forward declaration of `ExposureMode` to properly resolve imports.
namespace margelo::nitro::camera { enum class ExposureMode; }
// Forward declaration of `WhiteBalanceMode` to properly resolve imports.
namespace margelo::nitro::camera { enum class WhiteBalanceMode; }
// Forward declaration of `ColorSpace` to properly resolve imports.
namespace margelo::nitro::camera { enum class ColorSpace; }

#include <memory>
#include "HybridCameraFormatSpec.hpp"
#include <optional>
#include "Range.hpp"
#include "FocusMode.hpp"
#include "ExposureMode.hpp"
#include "WhiteBalanceMode.hpp"
#include "ColorSpace.hpp"

namespace margelo::nitro::camera {

  /**
   * A struct which can be represented as a JavaScript object (SetCameraDeviceConfiguration).
   */
  struct SetCameraDeviceConfiguration {
  public:
    std::optional<std::shared_ptr<HybridCameraFormatSpec>> activeFormat     SWIFT_PRIVATE;
    std::optional<std::shared_ptr<HybridCameraFormatSpec>> activeDepthFormat     SWIFT_PRIVATE;
    std::optional<bool> enableAutoFrameRate     SWIFT_PRIVATE;
    std::optional<Range> fps     SWIFT_PRIVATE;
    std::optional<FocusMode> focusMode     SWIFT_PRIVATE;
    std::optional<bool> enableSmoothAutoFocus     SWIFT_PRIVATE;
    std::optional<bool> enableFaceDrivenAutoFocus     SWIFT_PRIVATE;
    std::optional<ExposureMode> exposureMode     SWIFT_PRIVATE;
    std::optional<bool> enableFaceDrivenAutoExposure     SWIFT_PRIVATE;
    std::optional<WhiteBalanceMode> whiteBalanceMode     SWIFT_PRIVATE;
    std::optional<bool> automaticallyEnableLowLightBoost     SWIFT_PRIVATE;
    std::optional<bool> enableVideoHDR     SWIFT_PRIVATE;
    std::optional<bool> automaticallyEnableVideoHDR     SWIFT_PRIVATE;
    std::optional<bool> enableGlobalToneMapping     SWIFT_PRIVATE;
    std::optional<ColorSpace> colorSpace     SWIFT_PRIVATE;
    std::optional<double> zoom     SWIFT_PRIVATE;

  public:
    SetCameraDeviceConfiguration() = default;
    explicit SetCameraDeviceConfiguration(std::optional<std::shared_ptr<HybridCameraFormatSpec>> activeFormat, std::optional<std::shared_ptr<HybridCameraFormatSpec>> activeDepthFormat, std::optional<bool> enableAutoFrameRate, std::optional<Range> fps, std::optional<FocusMode> focusMode, std::optional<bool> enableSmoothAutoFocus, std::optional<bool> enableFaceDrivenAutoFocus, std::optional<ExposureMode> exposureMode, std::optional<bool> enableFaceDrivenAutoExposure, std::optional<WhiteBalanceMode> whiteBalanceMode, std::optional<bool> automaticallyEnableLowLightBoost, std::optional<bool> enableVideoHDR, std::optional<bool> automaticallyEnableVideoHDR, std::optional<bool> enableGlobalToneMapping, std::optional<ColorSpace> colorSpace, std::optional<double> zoom): activeFormat(activeFormat), activeDepthFormat(activeDepthFormat), enableAutoFrameRate(enableAutoFrameRate), fps(fps), focusMode(focusMode), enableSmoothAutoFocus(enableSmoothAutoFocus), enableFaceDrivenAutoFocus(enableFaceDrivenAutoFocus), exposureMode(exposureMode), enableFaceDrivenAutoExposure(enableFaceDrivenAutoExposure), whiteBalanceMode(whiteBalanceMode), automaticallyEnableLowLightBoost(automaticallyEnableLowLightBoost), enableVideoHDR(enableVideoHDR), automaticallyEnableVideoHDR(automaticallyEnableVideoHDR), enableGlobalToneMapping(enableGlobalToneMapping), colorSpace(colorSpace), zoom(zoom) {}
  };

} // namespace margelo::nitro::camera

namespace margelo::nitro {

  // C++ SetCameraDeviceConfiguration <> JS SetCameraDeviceConfiguration (object)
  template <>
  struct JSIConverter<margelo::nitro::camera::SetCameraDeviceConfiguration> final {
    static inline margelo::nitro::camera::SetCameraDeviceConfiguration fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
      jsi::Object obj = arg.asObject(runtime);
      return margelo::nitro::camera::SetCameraDeviceConfiguration(
        JSIConverter<std::optional<std::shared_ptr<margelo::nitro::camera::HybridCameraFormatSpec>>>::fromJSI(runtime, obj.getProperty(runtime, "activeFormat")),
        JSIConverter<std::optional<std::shared_ptr<margelo::nitro::camera::HybridCameraFormatSpec>>>::fromJSI(runtime, obj.getProperty(runtime, "activeDepthFormat")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "enableAutoFrameRate")),
        JSIConverter<std::optional<margelo::nitro::camera::Range>>::fromJSI(runtime, obj.getProperty(runtime, "fps")),
        JSIConverter<std::optional<margelo::nitro::camera::FocusMode>>::fromJSI(runtime, obj.getProperty(runtime, "focusMode")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "enableSmoothAutoFocus")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "enableFaceDrivenAutoFocus")),
        JSIConverter<std::optional<margelo::nitro::camera::ExposureMode>>::fromJSI(runtime, obj.getProperty(runtime, "exposureMode")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "enableFaceDrivenAutoExposure")),
        JSIConverter<std::optional<margelo::nitro::camera::WhiteBalanceMode>>::fromJSI(runtime, obj.getProperty(runtime, "whiteBalanceMode")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "automaticallyEnableLowLightBoost")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "enableVideoHDR")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "automaticallyEnableVideoHDR")),
        JSIConverter<std::optional<bool>>::fromJSI(runtime, obj.getProperty(runtime, "enableGlobalToneMapping")),
        JSIConverter<std::optional<margelo::nitro::camera::ColorSpace>>::fromJSI(runtime, obj.getProperty(runtime, "colorSpace")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "zoom"))
      );
    }
    static inline jsi::Value toJSI(jsi::Runtime& runtime, const margelo::nitro::camera::SetCameraDeviceConfiguration& arg) {
      jsi::Object obj(runtime);
      obj.setProperty(runtime, "activeFormat", JSIConverter<std::optional<std::shared_ptr<margelo::nitro::camera::HybridCameraFormatSpec>>>::toJSI(runtime, arg.activeFormat));
      obj.setProperty(runtime, "activeDepthFormat", JSIConverter<std::optional<std::shared_ptr<margelo::nitro::camera::HybridCameraFormatSpec>>>::toJSI(runtime, arg.activeDepthFormat));
      obj.setProperty(runtime, "enableAutoFrameRate", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.enableAutoFrameRate));
      obj.setProperty(runtime, "fps", JSIConverter<std::optional<margelo::nitro::camera::Range>>::toJSI(runtime, arg.fps));
      obj.setProperty(runtime, "focusMode", JSIConverter<std::optional<margelo::nitro::camera::FocusMode>>::toJSI(runtime, arg.focusMode));
      obj.setProperty(runtime, "enableSmoothAutoFocus", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.enableSmoothAutoFocus));
      obj.setProperty(runtime, "enableFaceDrivenAutoFocus", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.enableFaceDrivenAutoFocus));
      obj.setProperty(runtime, "exposureMode", JSIConverter<std::optional<margelo::nitro::camera::ExposureMode>>::toJSI(runtime, arg.exposureMode));
      obj.setProperty(runtime, "enableFaceDrivenAutoExposure", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.enableFaceDrivenAutoExposure));
      obj.setProperty(runtime, "whiteBalanceMode", JSIConverter<std::optional<margelo::nitro::camera::WhiteBalanceMode>>::toJSI(runtime, arg.whiteBalanceMode));
      obj.setProperty(runtime, "automaticallyEnableLowLightBoost", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.automaticallyEnableLowLightBoost));
      obj.setProperty(runtime, "enableVideoHDR", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.enableVideoHDR));
      obj.setProperty(runtime, "automaticallyEnableVideoHDR", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.automaticallyEnableVideoHDR));
      obj.setProperty(runtime, "enableGlobalToneMapping", JSIConverter<std::optional<bool>>::toJSI(runtime, arg.enableGlobalToneMapping));
      obj.setProperty(runtime, "colorSpace", JSIConverter<std::optional<margelo::nitro::camera::ColorSpace>>::toJSI(runtime, arg.colorSpace));
      obj.setProperty(runtime, "zoom", JSIConverter<std::optional<double>>::toJSI(runtime, arg.zoom));
      return obj;
    }
    static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
      if (!value.isObject()) {
        return false;
      }
      jsi::Object obj = value.getObject(runtime);
      if (!nitro::isPlainObject(runtime, obj)) {
        return false;
      }
      if (!JSIConverter<std::optional<std::shared_ptr<margelo::nitro::camera::HybridCameraFormatSpec>>>::canConvert(runtime, obj.getProperty(runtime, "activeFormat"))) return false;
      if (!JSIConverter<std::optional<std::shared_ptr<margelo::nitro::camera::HybridCameraFormatSpec>>>::canConvert(runtime, obj.getProperty(runtime, "activeDepthFormat"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "enableAutoFrameRate"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::camera::Range>>::canConvert(runtime, obj.getProperty(runtime, "fps"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::camera::FocusMode>>::canConvert(runtime, obj.getProperty(runtime, "focusMode"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "enableSmoothAutoFocus"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "enableFaceDrivenAutoFocus"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::camera::ExposureMode>>::canConvert(runtime, obj.getProperty(runtime, "exposureMode"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "enableFaceDrivenAutoExposure"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::camera::WhiteBalanceMode>>::canConvert(runtime, obj.getProperty(runtime, "whiteBalanceMode"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "automaticallyEnableLowLightBoost"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "enableVideoHDR"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "automaticallyEnableVideoHDR"))) return false;
      if (!JSIConverter<std::optional<bool>>::canConvert(runtime, obj.getProperty(runtime, "enableGlobalToneMapping"))) return false;
      if (!JSIConverter<std::optional<margelo::nitro::camera::ColorSpace>>::canConvert(runtime, obj.getProperty(runtime, "colorSpace"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "zoom"))) return false;
      return true;
    }
  };

} // namespace margelo::nitro
